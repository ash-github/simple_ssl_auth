本工程是C++工程, 主要功能是为linux/win原始socket, "附加"SSL双向认证功能.
依赖库openssl, 已经静态编译进thirdpartyxxx中. 当然也可以自己替换.

由于业务需要, 本工程用的是SSL的一个分支TLS(版本TLS1.0). 当然也可以自己修改代码更改.

# 使用方法见src目录下xxx_demo.cpp代码. 一看就懂. 

# 理解加密通信连接简要步骤是:
1. client -> server：tcp连接

>>>>>>>>>>>>>>>>>> SSL连接建立过程开始 <<<<<<<<<<<<<<<<<<<<<<<<

2. client <- server：{数字证书, 内含公钥}
client检查数字证书有没有问题(通过CA). 数字证书可以保证该公钥确实是server的. 以此可以确定公钥是对的.

3. client -> server：{随机数字}

4. client <- server：{随机数字}[私钥|RSA]
client检查随机数字是否正确, 公钥谁都有, 我用了对的公钥解析, 那么以此可以确定server是对的.

5. client -> server：对称加密算法,密钥[公钥|RSA]
由于私钥只有服务器有, client->server这条链路的安全性可以保证, 所以在这条链路发送对称加密算法和其密钥很安全

>>>>>>>>>>>>>>>>>> SSL连接建立过程结束 <<<<<<<<<<<<<<<<<<<<<<<<

6. client <- server：{OK，收到!}[对称加密算法|密钥]

7. client -> server：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[对称加密算法|密钥]

8. client <- server：{你的余额是100元}[对称加密算法|密钥]
Ps: 一般公钥用于加密, 私钥用于解密. 但是4里私钥用来加密. 公钥用于解密. 这里是RSA的特性.


# 理解整个SSL/TLS验证用到的文件和单双向验证区别(见如下是示意图). 
1. 可以看到CA是同一个. 因为客户端/服务端证书(ce.pem)和私钥(pr.key), 都是用它来生成的. 所以证书的有效性必须由它来验证.
2. 私钥(pr.key)用于解密加密数据, 不会发送给对端. 证书(ce.pem)会发送给对端, 用于对端加密数据. 
3. 证书(ce.pem)发送给对端后, 对端会通过CA先验证是否是该CA颁发的. 以校验合法性.
4. 单向验证是客户端验证服务端的合法性.
5. 双向验证是客户端服务端互相验证合法性.

单向验证
server                  client
                +-----> CA.pem
ce.pem(s) +-----+    
pr.key(s)

双向验证
server                  client
CA.pem    <----+   +--> CA.pem
ce.pem(s) -----|--+     pr.key(c)
pr.key(s)      +------- ce.pem(c)

# linux平台编译方式: make

# win平台编译方式: 使用vs2010打开xxx_demo.vcxproj编译.

# qt_demo.xxx是qt creator工程文件, 如果不需要可以忽视.

